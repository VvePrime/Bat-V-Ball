ORM solved object-relational-impedance-mismatch
ORM is a concept of mapping classes and its attributes in Object oriented programming to tables and its columns in relational database.

Hibernate is an ORM framework which implements the specification of JPA.

To implement ORM in java, JPA is used.
JPA is a specification which defines standards to implement/use ORM pattern. JPA acts as bridge between objects and tables.
Basically JPA provides the standards that are needed to be followed when mapping objects to tables
 - provides API for CRUD operations
 -  API to map classes with tables
 - JPQL to fetch data from database
 - Criteria API which uses object graph to fetch data from database
JPA is just a specification. so it needs implementation.
Hiberante is one of such ORM frameworks which implements the standards defined by JPA

Spring Data helps us reduce the coding required for Database.


@Entity classes- classes which are mapped with tables in database and whose one instance represents a row in the database
@Transient - an anootation for attributes of an entity class which are not to be saved/ stored into the table

@Enumerated(EnumType.String)/(EnumType.Ordinal)
- type string stores the actual enum value defined in the enum class. ordinal saves the values as 0,1,2 etc in the database.

@Transactional = transaction.being() -> transaction.commit()/transaction.rollback()	

Spring Data creates queries from method names, query inside @QUery annotation on method in repository and using @NamedQUery on the entity class with method name and query
- all these methods should be declared in repository class.
Hibernate:
Service registry api is responsible to hold manage and provide access to services. ServiceRegistry builder helps create ServiceRegistry instances.
Session factory api is responsible for the communication between the applicationa nd the databse
Transaction is a single unit of work done through session.

@Embeddable on an class reffered in an @Entity class - when entity class obj is saved to database then all the fields of embeddable class will be added to entity table

@OneToOne will add column only to the table in which we defined the relationship.
@OneToMany will always create a new table to define relation unless we give a parameter (mapped="variableNameInClassWithManyToOne")
@ManyToMany will always create a new table. will create 2 tables if one of the entities dont give the above mentioned mapped parameter.

default fetching type is lazy - if you query for aliens, it will not fetch laptops also
inorder to fetch laptops also you need to give fetch type param in relationship annotation ex: @OneToOne(fetch="fetchType.Eager")

hibernate cache - first level cache enabled by default
first level cache is session specific - cannot be accessed by a different session.
 second level cache needs dependencies, configuration and annotations on entity.

2nd level cache entity annotations @Cacheable - to enable caching @cache(Cachetype = readonly) to define the operations on which cacheing is allowed.
to use 2nd level cache while executing queries, we need to enable use query cache in configuration and set cachebale on query object to true.


Hibernate Object states is also called as persistence life cycle
transient - plain object not connected to db
persistent - when object is fetched from db or saved to db it goes into this state and stays in this state until we detach() or commit()
detached - in this state the object if we are changing its values wont reflect in the database unless we save it again.
removed - object goes into this state when it is removed from database

get - hits the database even if the object we got from db isnt used. - gives null result for object not present
load - wont hit the database until the object data is used. - throws exception for object not present( ObjectNotFoundException )

If we download hibernate or any other ORM framework for java they by default implement JPA.
- when downloaded these dependencies have jakarta.persistnece library available.
JPA sets standards so if we need to shift to a different ORM framework, JPA implementations need not be changed and it will be easier with fewer changes.


HQL 
concatenating the value to query with is a bad idea as sqlInjection might happen
- position parameter uses ? with 0,1,2 etc as positions -> query.setString()/setInt() etc
-  named parameter uses : with the word that we give after the colon as the parameter name -> query.setParameter()/setString()

@NamedQuery/@NamedQueries are part of hibernate also - session.getNamedQuery("namedQUeryName")

@Id generation:
-increment - takes max val from database adds 1 and generates - @GenericGenerator on @Entity, @GeneratedValue() on @Id field
-identity - primary key needs to have auto_increment feature - @GeneratedValue() on @Id fielt
-sequence - uses sequence defined in underlying database
- assigned strategy - this is the default strategy where we assign id value manually before saving to database

??
Object relational impedance mismatch
Hibernate APIs- service registry, session factory, session, transaction factory, transaction, connection Provider.
@Id generation strategies.